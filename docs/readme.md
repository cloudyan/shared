# 基础库设计

## 背景与现状

前端目前 utils 以及公共基础模块，存在很多问题

1. 职责不清晰
   a. utils 目录比较乱，承载了过多职责，既有工具函数，又有业务逻辑
   b. 存在大量业务相关的工具函数(如 apiCommon.js、commonUtils.ts)
   c. SDK 和路由等核心模块与普通工具函数混在一起
2. 代码组织混乱
   a. 文件命名不规范(如 tool.ts、helper.ts 职责重叠)
   b. 存在大量重复代码(如 storage 相关逻辑分散在多个文件)
   c. 缺乏模块化思维(文件之间存在复杂依赖)
3. 类型定义不完善
   a. 部分文件仍使用 .js类型
   b. 定义分散，缺乏统一管理
   c. 存在大量 any 类型
4. 缺乏扩展性平台适配
   a. 逻辑耦合在具体实现中
   b. 配置项硬编码

## 解决方案

封装统一，跨端兼容，为业务提供统一的 API

1. 分层解耦:
   a. 每一层都有明确的职责边界
   b. 层与层之间通过接口通信,避免直接依赖
   c. 下层不依赖上层,保持单向依赖
2. 模块化设计:
   a. 每个模块职责单一
   b. 模块之间低耦合
   c. 提供统一的API设计
3. 类型系统:
   a. 完善的TypeScript类型定义
   b. 统一的类型命名规范
   c. 类型与实现分离
4. 测试覆盖:
   a. 单元测试覆盖核心逻辑
5. 文档规范:
   a. 详细的API文档
   b. 使用示例
   c. 版本变更说明

迁移策略，渐进式迁移:

1. 划分优先级,分批迁移
2. 保证向下兼容


## 基础库模块设计

1. 采用 monorepo 仓库，实现模块管理
2. 采用 jest 实现自动化测试，保证代码质量
3. 仓库：jrfed-shared （需要新建）

基础库模块列表

1. device 设备模块，实现设备判断
   a. 设备  安卓、iOS、鸿蒙
   b. 容器运行时 微信、微信小程序、抖音小程序、众安贷 app 内 等等
2. storage 存储模块，实现跨端存储
   a. 通过对应端的底层 api，封装统一的跨端 API
3. runtimeEnv 运行环境
   a. 代码的运行环境，dev, uat, prd
   b. 小贷，taroweb 等
4. router 路由模块
   a. 封装路由，统一跳转逻辑
5. request 请求库封装
   a. 封装统一 API，适配 axios，Tar   o. request
6. url  URL解析模块
   a. 解析 URL
   b. 拼接 URL
7. 埋点模块
   a. 封装神策埋点，统一 API
8. 监控
   a. 封装统一的 API，对接小程序或六翼埋点
9. bride 桥模块
   a. 封装统一 API，适配新桥、老桥、鸿蒙等
10. 加密模块
   a. 接口加解密
11. 公参模块
   a. 处理公共参数
12. supplierCode 模块
   a. 封装 supplierCode 逻辑
13. utils
   a. 各种小工具方法，如金额处理，卡号格式化、正则校验等等
   b. 时间格式，可统一使用 dayjs 即可

## 设计方案

每个模块单独出设计方案

## 业务基础模块

非通用的，或具有特定业务属性的，且提供基础能力的，应为业务基础模块

列表如下，可按需提取、丰富

- 特定业务场景
  - 如 isMiniProgram() 判断小贷的小程序内，依赖 device, strorage, url, appIdConfig 等模块
- 授信的 flow 公共逻辑
- 小贷初始化逻辑 initStatus
- 风控信息
- 设备信息加工
- 协议跳转
- 挽留弹窗的挽留逻辑控制
- 图片压缩
- ...

业务相关模块，在业务项目中维护即可

## 单测覆盖

基础模块作为底层支撑，改动一般会影响较大，对质量要求更高，但模块功能相对稳定，适合做单元测试，用来做质量把控

单测可以采用 jest 或 vitest 实现
